{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About me","text":"<p>Hi, I\u2019m Aashritha! \ud83d\udc4b\ud83c\udffb  </p> <p>I\u2019m a third-year Computer Science student at STLW, Hyderabad, India.  </p> <p>I enjoy exploring machine learning, building websites just for fun, and sharing notes to make exam prep easier (and way less stressful). \ud83e\udd13\u261d\ud83c\udffc  </p> <p>\ud83d\udd17 Blog Page \ud83d\udd17 GitHub: Aashritha014 \ud83d\udd17 E-mail: s.aashritha14@gmail.com </p> <p>These notes are crafted to make your college exam prep easier, smarter, and maybe even a little fun \u2728</p> <p>Open Source Alert This website is open source, so if you spot ways to make the notes clearer or want to add your own magic, contributions are more than welcome. Peek at the code, suggest improvements, or submit a pull request.</p> <ul> <li>GitHub Repository: DBMS-Notes </li> </ul>"},{"location":"dbms/","title":"Overview","text":"<p>Welcome to  Database Management Systems (DBMS) notes This page is organized into 5 units with detailed topics and explanations. Explore each unit below.  </p>"},{"location":"dbms/#units","title":"Units","text":"<p>Unit 1: Introduction to DBMS</p> <p>Topics: History of DBMS | File System Approach | View of Data | Data Abstraction | Data Independence | EF Codd rules | DB: Languages | DB: Design Process | DB: Architecture | DBS: Architecture</p> <p>Full Unit 1</p> <p>Unit 2: Relational Model &amp; Introduction to SQL</p> <p>Topics: Relational Algebra Operations | Data Types and Schema | Aggregate Functions | Set Operations | Key Constraints | Integrity Constraints | Query Structure | Views | Procedure | Trigger | Cursors | Indexing</p> <p>Full Unit 2</p> <p>Unit 3: Data Base Design and ER Model</p> <p>Topics: ER: Diagram | ER: Reduction to Relational Schemas | ER: Extended Features | Features of Good Relational Designs | Functional Dependency Theorem | Algorithms for Decomposition | Functional Dependencies | Armstrong Axioms | Need for Normalisation | Normalisation | Denormalization | NoSQL Databases</p> <p>Full Unit 3</p> <p>Unit 4: Indexing, Hashing and Transaction</p> <p>Topics: Indexing | Hashing | A Simple Transaction Model | Transaction | Storage Structure | Schedules | Types of Schedules | Conflict Serialisability | View Serialisability | Implementation of Isolation Level Storage | Transaction as SQL Statements</p> <p>Full Unit 4</p> <p>Unit 5: Concurrency Control</p> <p>Topics: Concurrency Control | Lock Based Protocol | Multiple Granularity | Timestamp Based Protocols | Validation Based Protocols | Weak Levels of Consistency in Practice | Failure Classification | Storage Structure | Recovery and Atomicity | Log Based Recovery | Recovery with Concurrent Transaction | Buffer Management | Failure with Loss of Non-Volatile Storage | Advanced Recovery Techniques | Remote Backup Systems</p> <p>Full Unit 5</p>"},{"location":"os/","title":"Overview","text":"<p>Welcome to  Operating System(OS) Notes This page is organized into 5 units with detailed topics and explanations. Explore each unit below.  </p>"},{"location":"os/#units","title":"Units","text":"<p>Unit 1: Introduction to DBMS</p> <p>Topics: History of DBMS | File System Approach | View of Data | Data Abstraction | Data Independence | EF Codd rules | DB: Languages | DB: Design Process | DB: Architecture | DBS: Architecture</p> <p>Full Unit 1</p> <p>Unit 2: Relational Model &amp; Introduction to SQL</p> <p>Topics: Relational Algebra Operations | Data Types and Schema | Aggregate Functions | Set Operations | Key Constraints | Integrity Constraints | Query Structure | Views | Procedure | Trigger | Cursors | Indexing</p> <p>Full Unit 2</p> <p>Unit 3: Data Base Design and ER Model</p> <p>Topics: ER: Diagram | ER: Reduction to Relational Schemas | ER: Extended Features | Features of Good Relational Designs | Functional Dependency Theorem | Algorithms for Decomposition | Functional Dependencies | Armstrong Axioms | Need for Normalisation | Normalisation | Denormalization | NoSQL Databases</p> <p>Full Unit 3</p> <p>Unit 4: Indexing, Hashing and Transaction</p> <p>Topics: Indexing | Hashing | A Simple Transaction Model | Transaction | Storage Structure | Schedules | Types of Schedules | Conflict Serialisability | View Serialisability | Implementation of Isolation Level Storage | Transaction as SQL Statements</p> <p>Full Unit 4</p> <p>Unit 5: Concurrency Control</p> <p>Topics: Concurrency Control | Lock Based Protocol | Multiple Granularity | Timestamp Based Protocols | Validation Based Protocols | Weak Levels of Consistency in Practice | Failure Classification | Storage Structure | Recovery and Atomicity | Log Based Recovery | Recovery with Concurrent Transaction | Buffer Management | Failure with Loss of Non-Volatile Storage | Advanced Recovery Techniques | Remote Backup Systems</p> <p>Full Unit 5</p>"},{"location":"os_unit1/","title":"Operating System","text":"<ul> <li>An Operating System(OS) is a software that manages and handles hardware and software resources of a computing device.</li> <li>It provides a user interface and enables communication between computer hardware and software</li> <li> <p>Responsible for managing and controlling all the activities and sharing of computer resources among different running applications.</p> <p></p> </li> <li> <p>Example: Linux, Unix, Windows 11, Android, macOS</p> </li> <li>Kernal:<ul> <li>The software that contains the core components of the OS is called the\u00a0kernel</li> <li>It is responsible for all major operations and interaction with the hardware.</li> <li>A low-level Software that includes all the basic functions like processor management, memory management, file management, etc.</li> </ul> </li> <li>Shell:<ul> <li>Shell is an interface of an OS. It can be command line interface or a graphical user interface.</li> <li>User interacts with an OS using shell. Application programs can also use shell interface to interact with underlying OS.</li> </ul> </li> </ul>"},{"location":"os_unit1/#os-generations","title":"OS: Generations","text":"<ul> <li>0th Generation<ul> <li>1940 - early 1950s</li> <li>vacuum tubes and plug boards</li> </ul> </li> <li>1st Generation<ul> <li>1951-1956</li> <li>transistors and batch systems</li> </ul> </li> <li>2nd Generation<ul> <li>1956-196</li> <li>Integrated Circuits and multi programming</li> </ul> </li> <li>3rd Generation<ul> <li>1964-1979</li> <li>personal computers</li> </ul> </li> </ul>"},{"location":"os_unit1/#computer-system-operation","title":"Computer System Operation","text":"<ul> <li>A modern say general purpose computer consists of one or more CPU and a number of device controllers connected through a common bus that provides access to shared memory</li> <li>Each device controller is in charge of a specific type of device</li> <li>The CPU and the dc can execute concurrently, competing for memory cycles</li> <li> <p>To ensure orderly access to the shared memory, a memory controller is provided who\u2019s function is to synchronise access to the memory</p> </li> <li> <p>CPU:</p> <ul> <li>Executes instructions and processes data.</li> <li>Components:<ul> <li>Control Unit (CU):\u00a0Directs data flow.</li> <li>Arithmetic Logic Unit (ALU):\u00a0Performs arithmetic and logical operations.</li> <li>Registers:\u00a0Store temporary data for quick access.</li> </ul> </li> </ul> </li> <li>Memory (Primary Storage):<ul> <li>RAM (Random Access Memory): Volatile, fast storage for active programs/data.</li> <li>ROM (Read-Only Memory): Non-volatile, stores firmware (e.g., BIOS).</li> </ul> </li> <li>I/O Devices:<ul> <li>Keyboards, mice, monitors, printers, etc.</li> <li>Managed via\u00a0device drivers\u00a0(software that interfaces with hardware).</li> </ul> </li> <li>Storage Devices (Secondary Storage):<ul> <li>HDDs, SSDs, USB drives (non-volatile, slower than RAM).</li> </ul> </li> <li>Buses:<ul> <li>Communication channels between components (e.g., data bus, address bus).</li> </ul> </li> <li>Bootstrap Program:<ul> <li>bootstrap program is loaded at power-up or reboot</li> <li>Typically stored in ROM or EPROM, generally known as firmware</li> <li>Initialises all aspects of system</li> <li>Loads operating system kernel and and starts execution</li> </ul> </li> <li>Interrupt:<ul> <li>The occurence of an event is usually signalled by an interrupt from hardware or software</li> <li>hardware may trigger an interrupt at any time by sending a signal to the CPU using the system bus</li> </ul> </li> <li>System Call:<ul> <li>Software may trigger an interrupt by executing a special operation called as a system call(monitor call)</li> </ul> </li> </ul>"},{"location":"os_unit1/#io-structure","title":"I/O Structure","text":"<p>A large portion of an operating system\u2019s code is dedicated to managing\u00a0I/O due to its importance in ensuring system reliability and performance. Additionally, the diverse nature of devices requires efficient handling mechanisms.</p>"},{"location":"os_unit1/#basic-io-mechanism","title":"Basic I/O Mechanism","text":"<ol> <li>System Components:<ul> <li>A general-purpose computer system consists of a\u00a0CPU\u00a0and multiple\u00a0device controllers, which are connected through a\u00a0common bus.</li> <li>Each\u00a0device controller\u00a0has:<ul> <li>Local buffer storage\u00a0for temporary data holding.</li> <li>General-purpose registers\u00a0for control and status information.</li> </ul> </li> </ul> </li> <li>Role of Device Controllers:<ul> <li>The\u00a0device controller\u00a0manages data transfer between the\u00a0peripheral device\u00a0and its\u00a0local buffer storage.</li> <li>The\u00a0OS communicates\u00a0with the device controller using a\u00a0device driver, which acts as an interface between the OS and hardware.</li> <li>Each\u00a0device controller has a corresponding device driver, which understands its specific operations and provides a uniform interface to the OS.</li> </ul> </li> </ol>"},{"location":"os_unit1/#io-operation-flow","title":"I/O Operation Flow","text":"<ol> <li>The\u00a0OS initiates an I/O operation\u00a0by instructing the\u00a0device driver\u00a0to load the necessary registers within the\u00a0device controller.</li> <li>The\u00a0device controller\u00a0examines the register contents to determine the required action.</li> <li>The controller\u00a0transfers data\u00a0from the peripheral device to the\u00a0local buffer.</li> <li>Upon completion, the\u00a0device controller sends an interrupt\u00a0to notify the OS that the operation is finished.</li> <li> <p>The\u00a0device driver handles the interrupt, completes the necessary processing, and\u00a0returns control to the OS.</p> </li> <li> <p>Interrupt-Driven I/O:</p> <ul> <li>Suitable for transferring\u00a0small amounts of data.</li> <li>However, it generates a\u00a0high overhead\u00a0for bulk data transfers (e.g., disk I/O) because an\u00a0interrupt is triggered for each byte of data.</li> </ul> </li> <li>Direct Memory Access (DMA):<ul> <li>Used for transferring\u00a0large blocks of data\u00a0efficiently.</li> <li>The\u00a0device controller\u00a0is responsible for moving an entire block of data\u00a0directly between the device and memory\u00a0without CPU intervention.</li> <li>The CPU only receives\u00a0one interrupt per block\u00a0(instead of one per byte), reducing overhead.</li> <li>While DMA is in progress, the\u00a0CPU remains free\u00a0to perform other tasks, improving overall system efficiency.</li> </ul> </li> </ol>"},{"location":"os_unit1/#storage-structure","title":"Storage Structure","text":"<p>A\u00a0storage system\u00a0provides:</p> <ol> <li>Storing data\u00a0for later retrieval.</li> <li>Holding data\u00a0until accessed.</li> </ol> <p>The key differences between various storage types are:</p> <ul> <li>Speed\u00a0(faster storage is generally more expensive).</li> <li>Cost per bit\u00a0****(decreases as we move down the hierarchy).</li> <li>Size\u00a0(higher levels store less data, lower levels store more).</li> <li>Volatility\u00a0(some storage types lose data when power is lost).</li> <li>Registers:<ul> <li>located inside the CPU, these store data in bits and can be accessed quickly</li> <li>It can hold small amount of data (32 to 64 bits)</li> <li>It is volatile in nature</li> <li>ex: instruction Register (IR), Accumulator, Stack Pointer.</li> </ul> </li> <li>Cache:<ul> <li>Located in between CPU and RAM. It is faster that RAM but slower than registers</li> <li>It stores frequently accessed data and instructions to speed up processing and reduces access to the slower main memory</li> <li>It is volatile in nature</li> </ul> </li> <li>Main Memory[RAM]:<ul> <li>It is directly accessible by CPU</li> <li>It is slower than cache but faster than secondary storage</li> <li>It is volatile in nature and holds active processes, programs, and data currently in use.</li> <li>Dynamic RAM (DRAM):\u00a0Used in main memory, slower than SRAM.</li> <li>Static RAM (SRAM):\u00a0Faster but used mainly for cache memory.</li> </ul> </li> </ul> <p>Secondary Storage:</p> <p>Used for data backup, archival storage, and infrequently accessed data.Non volatile in nature </p> <ul> <li>Solid-State Drive (SSD):<ul> <li>The SSD have several variants but in general are faster than Magnetic disk and are non-volatile</li> <li>Uses flash memory, faster but expensive.</li> </ul> </li> <li>Magnetic Disk<ul> <li>Hard Disk Drive (HDD):\u00a0Uses spinning magnetic disks, slower but cheaper</li> </ul> </li> </ul> <p>Tertiary Storage: </p> <p>Used for\u00a0long-term storage, offline storage, and backups.</p> <p>External devices, cloud, or offline storage.</p> <ul> <li>Optical Disk<ul> <li>Used for media storage and backups.</li> </ul> </li> <li>Magnetic Tapes<ul> <li>Used for long-term data storage.</li> </ul> </li> </ul>"},{"location":"os_unit1/#os-structures","title":"OS: Structures","text":"<ul> <li>An operating system is a structure that allows the user application programs to interact with the system hardware</li> <li>Since the operating system is such a complex structure, it should be created with utmost care so it can be used and modified easily.</li> <li>An easy way to do this is to create the operating system in parts.</li> <li>Each of these parts should be well defined with clear inputs, outputs and functions.</li> </ul>"},{"location":"os_unit1/#simple-structure","title":"Simple Structure","text":"<ul> <li>Lacks a well-defined structure and is typically implemented as a monolithic system.</li> <li>Functions are not separated into distinct modules, leading to direct interaction between components.</li> <li>example: MS-DOS</li> <li>Provides basic functionalities with minimal separation.</li> <li>Kernel and application programs interact without clear boundaries, making the system efficient but hard to maintain.</li> <li>Advantages:\u00a0Fast execution due to fewer layers.</li> <li>Disadvantages:\u00a0Difficult to extend and debug due to tight coupling.</li> </ul>"},{"location":"os_unit1/#layered-structure","title":"Layered Structure","text":"<ul> <li>An OS can be broken into pieces and retain much more control over the system.</li> <li>In this structure, the OS is broken into a number of layers (levels).</li> <li>The bottom layer (layer 0) is the hardware, and the topmost layer (layer N) is the user interface.</li> <li>These layers are so designed that each layer uses the functions of the lower-level layers</li> <li>One problem with the layered structure is that each layer needs to be carefully defined. This is necessary because the upper layers can only use the functionalities of the layers below them.</li> <li>Advantages<ul> <li>High Customizable\u00a0- Being layered, each layer implmentation can be customized easily. A new functionality can be added without impacting other modules as well</li> <li>Verifiable\u00a0- Being modular, each layer can be verified and debugged easily.</li> </ul> </li> <li>Disadvantages<ul> <li>Less Performant\u00a0- A layered structured operating system is less performant as compared to basic structured operating system.</li> <li>Complex designing\u00a0- Each layer is to planned carefully as each layer communicates with lower layer only and a good design process is required to create a layered operating system.</li> </ul> </li> </ul>"},{"location":"os_unit1/#micro-kernal-structure","title":"Micro Kernal Structure","text":"<ul> <li>In micro-kernel, we have multiple kernels each one specilized in particular service</li> <li>Each microkernel is developed independent to the other one and makes system more stable</li> <li>If one kernel fails the operating sytem will keep working with other kernel's functionalities.</li> <li>Advantages<ul> <li>Reliable and Stable\u00a0- As multiple kernels are working simultaneously, chances of failure of operating sytem is very less. If one functionlity is down, operating system can still provide other functionalities using stable kernels</li> <li>Maintainability\u00a0- Being small sized kernels, code size is maintainable. One can enhance a microkernel code base without impacting other microkernel code base.</li> </ul> </li> <li>Disadvantages<ul> <li>Complex to Design\u00a0- Such a microkernel based architecture is difficult to design.</li> <li>Performance Degradation\u00a0- Multi kernel, Multi-modular communication may hamper the performance as compared to monolith architecture.</li> </ul> </li> </ul>"},{"location":"os_unit1/#modular-structure","title":"Modular Structure","text":"<ul> <li>It is considered as the best approach for an OS. It involves designing of a modular kernel.</li> <li>The kernel has only a set of core components and other services are added as dynamically loadable modules to the kernel either during runtime or boot time.</li> <li>It resembles layered structure due to the fact that each kernel has defined and protected interfaces, but it is more flexible than a layered structure as a module can call any other module.</li> <li>Advantages:<ul> <li>High Customizable\u00a0- Being modular, each module implmentation can be customized easily. A new functionality can be added without impacting other modules as well.</li> <li>Verifiable\u00a0- Being modular, each layer can be verified and debugged easily.</li> </ul> </li> <li>Disadvantages:<ul> <li>Less Performant\u00a0- A modular structured operating system is less performant as compared to basic structured operating system.</li> <li>Complex designing\u00a0- Each module is to planned carefully as each module communicates with kernal. A communication API is to be devised to facilitate the communication.</li> </ul> </li> </ul>"},{"location":"os_unit1/#os-types","title":"OS: Types","text":""},{"location":"os_unit1/#batch-os","title":"Batch OS","text":"<ul> <li>This type of operating system does not interact with the computer directly.</li> <li>There is an operator which takes similar jobs having the same requirements and groups them into batches.</li> <li>It is the responsibility of the operator to sort jobs with similar needs.</li> <li>Batch OS is designed to manage and execute a large number of jobs  sequentially without user intervention and efficiently by processing them in groups</li> <li>IBM introduced FORTRAN IBSYS 7096 for this</li> <li>Example: Payroll Systems, Bank Statements, etc.</li> <li> <p>Advantages</p> <ul> <li>Multiple users can share the batch systems.</li> <li>It is easy to manage large work repeatedly in batch systems.</li> </ul> </li> <li> <p>Disadvantages</p> <ul> <li>CPU is not used efficiently. When the current process is doing IO, CPU is free and could be utilised by other processes waiting.</li> <li>The other jobs will have to wait for an unknown time if any job fails.</li> <li>In batch os, average response time increases as all processes are processed one by one.</li> </ul> </li> </ul>"},{"location":"os_unit1/#multi-programming-os","title":"Multi-Programming OS","text":"<ul> <li>Multiprogramming OS allows multiple programs to be\u00a0loaded into memory and executed concurrently, maximizing\u00a0CPU utilization.</li> <li>It was developed to overcome the limitations of Batch OS, where the CPU often remained idle while waiting for I/O operations.</li> <li>The OS manages their execution based on\u00a0priority and availability of resources.</li> <li>The OS divides memory among different programs using\u00a0partitioning techniques\u00a0(Fixed or Dynamic Partitioning).</li> <li>If one process is waiting for I/O (e.g., reading from a disk), the CPU switches to another process.This process of switching between programs is called\u00a0context switching.This reduces CPU idle time and increases\u00a0throughput.</li> <li>Advantages<ul> <li>Maximises CPU Utilisation</li> <li>Increases Throughput</li> <li>Efficient Resource Management</li> </ul> </li> <li>Disadvantages<ul> <li>Requires efficient allocation of memory to multiple programs.</li> <li>Higher Response Time since some processes may have to wait longer for CPU time.</li> <li>Risk of Deadlock as multiple processes may wait for resources indefinitely.</li> </ul> </li> </ul>"},{"location":"os_unit1/#multi-taksing-os","title":"Multi-Taksing OS","text":"<ul> <li>It is a type of Multiprogramming system with every process running in round robin manner where not only are multiple programs loaded into memory, but they are also executed\u00a0concurrently with time-sharing.</li> <li>The OS\u00a0allocates a fixed time slice\u00a0to each process</li> <li> <p>The time that each task gets to execute is called quantum. After this time interval is over OS forcibly switches over to the next process.</p> </li> <li> <p>Advantages</p> <ul> <li>Ensures that no process keeps the CPU idle for long.</li> <li>Improves user experience by switching between tasks quickly.</li> <li>Users can run multiple applications simultaneously.</li> </ul> </li> <li>Disadvantages<ul> <li>Risk of overloading as too many processes can slow down performance.</li> <li>Running multiple applications consumes more memory.</li> <li>Requires advanced scheduling and memory management.</li> </ul> </li> </ul>"},{"location":"os_unit1/#multi-processing-os","title":"Multi-Processing OS","text":"<ul> <li>a type of Operating System in which more than one CPU is used for the execution of resources.</li> <li>It betters the throughput of the System.</li> <li>Advantages<ul> <li>It increases the throughput of the system as processes can be parallelized.</li> <li>As it has several processors, so, if one processor fails, we can proceed with another processor.</li> </ul> </li> </ul>"},{"location":"os_unit1/#time-sharing-os","title":"Time Sharing OS","text":"<ul> <li>The time interval required to process and respond to inputs is very small. This time interval is called\u00a0response time.</li> <li>Real-time systems\u00a0are used when there are time requirements that are very strict like missile systems,ATC, robots, etc.</li> <li>Hard Real-Time OS are meant for applications where time constraints are very strict and even the shortest possible delay is not acceptable</li> <li>Soft Real-Time OS are for applications where time-constraint is less strict</li> </ul>"},{"location":"os_unit1/#distributed-os","title":"Distributed OS","text":"<ul> <li>These types of operating system is a recent advancement in the world of computer technology and are being widely accepted all over the world and, that too, at a great pace.</li> <li>Various autonomous interconnected computers communicate with each other using a shared communication network.</li> <li>Independent systems possess their own memory unit and CPU. These are referred to as\u00a0loosely coupled systems or distributed systems These systems\u2019 processors differ in size and function.</li> <li>The major benefit of working with these types of the operating system is that it is always possible that one user can access the files or software which are not actually present on his system but some other system connected within this network i.e., remote access is enabled within the devices connected in that network.</li> <li>Advantages<ul> <li>Failure of one will not affect the other network communication, as all systems are independent of each other.</li> <li>Electronic mail increases the data exchange speed.</li> <li>Since resources are being shared, computation is highly fast and durable.</li> <li>Load on host computer reduces.</li> <li>These systems are easily scalable as many systems can be easily added to the network.</li> <li>Delay in data processing reduces.</li> </ul> </li> <li>Disadvantages<ul> <li>Failure of the main network will stop the entire communication.</li> <li>To establish distributed systems the language is used not well-defined yet.</li> <li>These types of systems are not readily available as they are very expensive. Not only that the underlying software is highly complex and not understood well yet.</li> </ul> </li> </ul>"},{"location":"os_unit1/#os-servies","title":"OS: Servies","text":"<p>An operating system provides a variety of essential services that help users and system programs interact with hardware efficiently. These services ensure system usability, resource management, and process control</p> <ol> <li>Program Execution:<ul> <li>The OS ensures smooth execution of user programs and system processes.</li> <li>Loads programs into memory for execution.</li> <li>Allocates CPU time for execution.</li> <li>Handles process creation, termination, and scheduling.</li> <li>Provides a mechanism for process communication.</li> <li>Provides a mechanism for deadlock handling.</li> </ul> </li> <li>Resource Allocation:<ul> <li>The OS allocates system resources efficiently among processes.</li> <li>CPU Scheduling:\u00a0Determines which process gets CPU time.</li> <li>Memory Allocation:\u00a0Assigns RAM space dynamically.</li> <li>Disk Management:\u00a0Allocates storage space for files.</li> <li>Device Management:\u00a0Handles I/O device sharing.</li> </ul> </li> <li>Communication:<ul> <li>Processes need to communicate for data sharing and coordination. The OS provides mechanisms for Inter-Process Communication (IPC).</li> <li>Shared Memory:\u00a0Processes share a common memory space for exchanging data.</li> <li>Message Passing:\u00a0Processes send and receive messages through system calls.</li> </ul> </li> <li>File System Manipulation:<ul> <li>Handles the creation, deletion, and organization of files and directories.</li> <li>File Organization:\u00a0Stores and organizes data in a structured manner.</li> <li>Access Control:\u00a0Manages user permissions (Read, Write, Execute).</li> <li>File Operations:\u00a0Provides commands for opening, reading, writing, closing files.</li> <li>File Sharing &amp; Security:\u00a0Ensures controlled access and protection of data</li> </ul> </li> <li>I/O Operation:<ul> <li>Coordinates input and output operations to communicate with hardware devices like keyboards, printers, and disk drives.</li> <li>Device Drivers:\u00a0Interfaces between OS and hardware devices.</li> <li>Buffering &amp; Caching:\u00a0Temporarily stores data for smooth processing.</li> <li>Interrupt Handling:\u00a0Manages signals from devices to the CPU.</li> </ul> </li> <li>Protection and Security:<ul> <li>Safeguards the system against unauthorized access and threats</li> <li>Authentication:\u00a0Ensures only authorized users access the system.</li> <li>Encryption:\u00a0Protects data from unauthorized modifications.</li> <li>Access Control:\u00a0Implements user permissions and policies.</li> <li>Threat Detection:\u00a0Identifies and prevents viruses and malware.</li> </ul> </li> <li>Error Detection:<ul> <li>The OS constantly monitors the system for hardware and software errors to ensure reliable operation.</li> <li>Logs errors for debugging.</li> <li>Displays error messages to users.</li> <li>Attempts error recovery (e.g., retries disk read/write operations).</li> <li>Prevents faulty programs from affecting system stability.</li> </ul> </li> <li>Accounting &amp; Tracking:<ul> <li>Monitors CPU, memory, and I/O usage.</li> <li>Tracks user logins and activity.</li> <li>Helps administrators optimize resource allocation.</li> <li>Used in cloud computing for usage-based billing</li> </ul> </li> <li>User Interface:<ul> <li>Provides an interface for users to interact with the system.</li> <li>Command-Line Interface (CLI):\u00a0Uses text-based commands (e.g., Linux Terminal).</li> <li>Graphical User Interface (GUI):\u00a0Uses visual elements (e.g., Windows, macOS).</li> </ul> </li> </ol>"},{"location":"os_unit1/#dual-mode-operation","title":"Dual Mode Operation","text":"<p>The\u00a0dual mode operation\u00a0ensures:</p> <ol> <li>Protection of the OS\u00a0from faulty or malicious user programs.</li> <li>Protection of user programs\u00a0from interfering with each other.</li> </ol> <p>This is achieved by restricting\u00a0certain critical operations\u00a0to a\u00a0privileged mode.</p>"},{"location":"os_unit1/#modes-of-operation","title":"Modes of Operation:","text":"<p>A computer system operates in\u00a0two modes:</p> <ul> <li>User Mode: Executes user applications with\u00a0restricted access\u00a0to system resources.</li> <li>Kernel Mode (Supervisor Mode / System Mode / Privileged Mode): Executes\u00a0OS instructions\u00a0with\u00a0full accessto hardware and system resources.</li> </ul> <p>A special hardware\u00a0mode bit\u00a0is used to indicate the current mode:</p> <ul> <li>0 \u2192 Kernel Mode</li> <li>1 \u2192 User Mode</li> </ul> <p>If an attempt is made to execute a privileged instruction in user mode, the hardware does not execute the instruction but rather treats it as illegal and traps it to the OS</p> <p>Dual mode of an OS provides:</p> <ul> <li>Security \u2192 Prevents unauthorized access to system resources.</li> <li>Stability \u2192 Protects the OS and user programs from errors and crashes</li> <li>Controlled Access \u2192 Ensures users can access system services safely.</li> </ul>"},{"location":"os_unit1/#working-of-dual-mode-operation","title":"Working of Dual Mode Operation:","text":"<ul> <li>There are two modes of operation user mode and kernel mode (supervisor mode, system mode, privileged mode)</li> <li>A bit mode called the mode bit, is added to the hardware of the computer to indicate the current mode: kernel mode(0) and user mode(1)</li> <li>When the computer system is executing on behalf of a user application it is in user mode.</li> <li>However, when an application requests a service from OS via a system call, the system transitions from user to kernel mode to full fill the request</li> <li>At system boot time, the hardware starts in kernel mode. The OS is then loaded and starts user applications in user mode.</li> <li>Whenever trap or interrupt occurs, the hardware switches from user mode to kernel (that is, changes the state of the mode bit to O).</li> <li>Thus, whenever the OS gains control of the computer, it is in kernel mode.</li> <li>The system always switches to user mode (by setting the mode bit to 1) before passing control user program.</li> </ul>"},{"location":"os_unit1/#computer-system-architerture","title":"Computer System Architerture","text":"<p>Based on number of general purpose processes we have:</p>"},{"location":"os_unit1/#single-system-processing","title":"Single System Processing","text":"<ul> <li>A single processor system contains only one processor.</li> <li>So only one process can be executed at a time and then the process is selected from the ready queue</li> <li>On a single processor system, there is one main CPU capable of executing a general purpose instruction , including instructions from user processes</li> <li>Almost all single processor systems have other special purpose processors as well</li> <li>All of these special purpose processors run a limited instruction set and do not run user processes</li> </ul> <p>Advantages:</p> <ul> <li>Simple System Architecture</li> <li>Easier to develop and maintain</li> </ul> <p>Disadvantages:</p> <ul> <li>Slower execution due to sequential processing</li> <li>High CPU load can cause performance bottlenecks</li> <li>Cannot execute multiple tasks simultaneously</li> </ul>"},{"location":"os_unit1/#multiple-system-processing","title":"Multiple System Processing","text":"<ul> <li>A multiprocessing operating system is defined as a type of operating system that makes use of more than one CPU to improve performance</li> <li>Multiple processors work parallelly in multi-processing os to execute tasks concurrently.</li> <li>These processors are in close communication, sharing the computer bus and sometimes the clock, memory and peripheral devices</li> </ul> <p>Advantages:</p> <ol> <li>Increased throughput: Multiple processing systems improve throughput by executing multiple tasks simultaneously, reducing idle time, and optimizing resource utilization by <ul> <li>Parallel Execution: tasks are divided among multiple CPUs and multiple processors execute different processes at the same time, reducing overall execution time and increasing efficiency</li> <li>Load Balancing:the system distributes tasks evenly among processors to prevent bottlenecks and dynamic load balancing ensures that no processor remains idle while others are overloaded.</li> <li>Efficient Process Scheduling: multiprocessing allows for better scheduling by making use of algorithms such as RR,SJF and priority scheduling</li> <li>Reduced Context Switching: MP reduce the need for switching, leading to higher throughput</li> <li>Reduced Waiting time for IO operations: while one processor handles computation, another can manage I/O operations, preventing idle time.</li> <li>Fault Tolerance and Redundancy: If one processor fails, others continue processing, preventing system downtime and maintaining throughput.</li> </ul> </li> <li>Economy of scale - Multiprocessor systems can cost less than equivalent multiple single processor systems because they can share peripherals, mass storage and power supplies.</li> </ol> <p>Disadvantages:</p> <ul> <li>Higher hardware and maintenance costs.</li> <li>Complexity in system design and synchronization.</li> <li>Requires special software to manage multiple processors</li> </ul>"},{"location":"os_unit1/#symmetric-multiple-processing","title":"Symmetric Multiple Processing","text":"<ul> <li>Multiple processors share the same physical memory and operate under a single OS, with each processor having equal access to system resources.</li> <li>Each processor has its own set of registers as well as local or private cache</li> <li>All CPUs access the same memory, leading to efficient communication</li> <li>Tasks are distributed evenly among processors to improve performance.</li> <li>Advantages:<ul> <li>Better Resource Utilization:\u00a0Each processor is able to work on a particular task and share the work load hence enhancing the performance.</li> <li>Scalability:\u00a0Additional processors can also be added to SMP systems hence they have a good potential for scaling.</li> <li>Fault Tolerance:\u00a0Due to the notion of distributed processing, where no single processor has control of the entire system, failure of one processor does not result in failure of the entire system</li> </ul> </li> <li>Disadvantages:<ul> <li>Complex Scheduling:\u00a0Tasks distribution among the multiple processors might be more challenging than the simple division of data among the cores and can involve logical functions of scheduling.</li> <li>Resource Contention:\u00a0Several processors might run for the same memory or I/O thus they might experience contention.</li> <li>Increased Hardware Costs:\u00a0SMP systems call for more elaborate hardware meant for the shared access between the processors and the memory and other system assets.</li> </ul> </li> </ul>"},{"location":"os_unit1/#asymmetric-multiple-processing","title":"Asymmetric Multiple Processing","text":"<ul> <li>One processor acts as a master whereas remaining all processors act a slaves.</li> <li>Slave processors are assigned with ready to execute processes by the master processor.</li> <li>A ready queue is being maintained by master processor to provides with processes for slaves.</li> <li>In multiprocessing operating system a schedular is created by master process that assigns processes to be executed to slave processors.</li> <li>Advantages:<ul> <li>Simplified Control:\u00a0Another advantage is that there is a single master processor who handles the task of scheduling so as to ensure co-ordination of tasks.</li> <li>Reduced Resource Conflicts:\u00a0This is made possible since only the master processor communicates with the operating system hence the conflicts between the processors are low.</li> </ul> </li> <li>Disadvantages:<ul> <li>Single Point of Failure:\u00a0Correspondingly, the operations of the system are largely contingent upon the master processor. When computer is splitter into master and other processors, if the master does not work, then the entire system can be non-operational.</li> <li>Less Efficient Resource Utilization:\u00a0Other subordinate processors may even remain idle due to the inability of master processor to assign tasks appropriately.</li> </ul> </li> </ul> Feature SMP AMP Definition Multiple processors share the OS and have equal control over system tasks. One master processor controls the system and assigns tasks to slave processors. Processor Equality All processors are equal. Processors are not equal. OS Task Management Tasks are distributed among individual processors. The master processor handles OS tasks. Processor Control All processors perform tasks independently. The master processor assigns tasks to slave processors. Workload Distribution Dynamic; any processor can execute any task. Fixed; tasks are pre-assigned to specific processors. Communication All processors communicate via shared memory. No direct communication; master processor controls everything. Fault Tolerance High; if one processor fails, others can take over. Low; failure of the master processor can halt the system. Efficiency High, as all processors share the workload equally. Lower efficiency due to dependency on the master processor. Complexity More complex due to synchronization and resource sharing. Simpler to implement since the master processor handles system tasks. Resource Sharing Shared memory and OS control among all processors. Limited sharing; master processor manages system resources. Scalability Highly scalable; additional processors can be added easily. Less scalable due to dependency on the master processor. Cost Expensive. Relatively inexpensive. Examples Multi-core CPUs, modern servers, supercomputers. Embedded systems, early multiprocessor systems, mobile devices."},{"location":"os_unit1/#clustered-systems","title":"Clustered Systems","text":"<ul> <li>Clustered systems are similar to parallel systems as they both have multiple CPUs.</li> <li>However a major difference is that clustered systems are created by two or more independent systems, with shared common storage and connected by a high-speed LAN, working together.</li> <li>Each node in the clustered systems contains the cluster software.</li> <li>This software monitors the cluster system and makes sure it is working as required.</li> <li> <p>If any one of the nodes in the clustered system fail, then the rest of the nodes take control of its storage and resources and try to restart.</p> </li> <li> <p>Advantages of Clustering Systems:</p> </li> <li>Fault Tolerance:<ul> <li>The loss of one node does not result in the loss of the system.</li> <li>They may even contain one or more nodes in hot standby mode which allows them to take the place of failed nodes.</li> </ul> </li> <li>Performance:<ul> <li>They work as a parallel unit and result in much better performance for the system.</li> </ul> </li> <li>Scalability:<ul> <li>It is easy to add a new node to the system.</li> </ul> </li> </ul>"},{"location":"os_unit1/#asymmetric-clustered-systems","title":"Asymmetric Clustered Systems","text":"<ul> <li>one of the nodes in the clustered system is in hot standby mode and all the others run the required applications.</li> <li>The hot standby mode is a failsafe in which a hot standby node is part of the system</li> <li>The hot standby node continuously monitors the server and if it fails, the hot standby node takes its place.</li> </ul>"},{"location":"os_unit1/#symmetric-clustered-systems","title":"Symmetric Clustered Systems","text":"<ul> <li>In symmetric clustering system two or more nodes all run applications as well as monitor each other.</li> <li>This is more efficient than asymmetric system as it uses all the hardware and doesn't keep a node merely as a hot standby</li> <li>Such systems can supply significantly greater computational power than single processor or even SMP systems because they can run an application concurrently on all computers in the cluster, this involves a technique known as parallelization which divides a program into separate components that run in parallel on individual computers in the cluster</li> </ul> Feature SPS MPS CS Definition A system with a single processor executing tasks sequentially. A system with multiple processors sharing workload within a single OS. A group of interconnected computers working together as a single system. No of Processors One More than one (Multiprocessing) Multiple independent computers (nodes) Execution Type Sequential execution of tasks. Parallel execution across multiple processors. Distributed execution across multiple machines. Performance Slower due to sequential execution. Faster due to shared processing. Very high performance, used for large-scale computing. Fault Tolerance Low; system fails if the processor crashes. Moderate; if one processor fails, others continue. High; if one node fails, others continue processing. Resource Sharing No sharing, all tasks handled by one CPU. Shared memory and resources among processors. Nodes communicate and share workload via a network. Scalability Limited; performance improves only by upgrading the single CPU. Scalable by adding more processors. Highly scalable by adding more nodes. Cost Low; requires only a single processor. Moderate; requires multiple processors in a single system. High; requires multiple computers and networking infrastructure. Examples Traditional personal computers. Multi-core processors, servers, supercomputers. Cloud computing, data centers, high-performance computing clusters."},{"location":"os_unit1/#system-calls","title":"System Calls","text":"<ul> <li>A system call\u00a0is a programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on</li> <li>A system call is a way for programs to\u00a0interact with the operating system.</li> <li>System call\u00a0provides\u00a0the services of the operating system to the user programs via the Application Program Interface(API).</li> <li>System calls are the only entry points into the kernel system and are executed in kernel mode.</li> </ul> Type Functions Description Process Control End, abort Terminates a process System calls related to creating, managing, and terminating processes. Load, execute Loads a program into memory and runs it Create process, terminate process Starts or stops a process Get process attributes, set process attributes Retrieves or modifies process-related information Wait for time Pauses a process for a specified duration Wait event, signal event Synchronizes processes through events Set and free memory Allocates or deallocates memory File Management Create, delete Creates or removes a file System calls for handling files and performing operations on them. Open, close Opens or closes an existing file Read, write, reposition Reads from, writes to, or moves within a file Get file attributes, set file attributes Retrieves or modifies file metadata Device Management Request device, release device Requests or releases access to a device System calls for interacting with hardware devices. Read, write, reposition Performs I/O operations on a device Get device attributes, set device attributes Retrieves or modifies device settings Logically attach or detach devices Connects or disconnects a device Information Maintenance Get time or date, set time or date Retrieves or updates the system clock System calls for retrieving or updating system-related information. Get system data, set system data Reads or modifies system-level information Get process, file, or device attributes Retrieves attributes of system components Set process, file, or device attributes Modifies attributes of processes, files, or devices Communication Create, delete communication connection Establishes or removes a communication channel System calls for interprocess and network communication. Send, receive messages Transfers data between processes or over a network Transfer status signal Sends control signals between processes Attach or detach remote devices Connects or disconnects remote devices"},{"location":"os_unit1/#system-design-and-implementation","title":"System Design and Implementation","text":""},{"location":"os_unit1/#design-goals","title":"Design Goals","text":"<ul> <li>Requirements\u00a0define properties which the finished system must have, and are a necessary first step in designing any large complex system.<ul> <li>User requirements\u00a0are features that users care about and understand, and are written in commonly understood vernacular. They generally do not include any implementation details, and are written similar to the product description one might find on a sales brochure or the outside of a shrink-wrapped box.</li> <li>System requirements\u00a0are written for the developers, and include more details about implementation specifics, performance requirements, compatibility constraints, standards compliance, etc. These requirements serve as a \"contract\" between the customer and the developers, ( and between developers and subcontractors ), and can get quite detailed.</li> </ul> </li> <li>Requirements for operating systems can vary greatly depending on the planned scope and usage of the system. ( Single user / multi-user, specialized system / general purpose, high/low security, performance needs, operating environment, etc. )</li> </ul>"},{"location":"os_unit1/#mechanisms-and-policies","title":"Mechanisms and Policies","text":"<ul> <li>Policies determine\u00a0what\u00a0is to be done. Mechanisms determine\u00a0how\u00a0it is to be implemented.</li> <li>If properly separated and implemented, policy changes can be easily adjusted without re-writing the code, just by adjusting parameters or possibly loading new data / configuration files. For example the relative priority of background versus foreground tasks.</li> </ul>"},{"location":"os_unit1/#implementation","title":"Implementation","text":"<ul> <li>Traditionally OSes were written in assembly language. This provided direct control over hardware-related issues, but inextricably tied a particular OS to a particular HW platform.</li> <li>Recent advances in compiler efficiencies mean that most modern OSes are written in C, or more recently, C++. Critical sections of code are still written in assembly language, ( or written in C, compiled to assembly, and then fine-tuned and optimized by hand from there. )</li> <li>Operating systems may be developed using\u00a0emulators\u00a0of the target hardware, particularly if the real hardware is unavailable ( e.g. not built yet ), or not a suitable platform for development, ( e.g. smart phones, game consoles, or other similar devices. )</li> </ul>"},{"location":"oslab/","title":"Overview","text":"<p>Welcome to Operating Systems Lab Programs This site is organized into 13 programs with detailed implementation and explanations. Explore each program below.  </p>"},{"location":"oslab/#programs","title":"Programs","text":"<p>Program 1: Unix System Calls</p> <p>Topics: fork() | wait() | exec() | sleep() | File Management</p> <p>Full Program 1</p> <p>Program 2: Multithread Concepts</p> <p>Topics: Thread Creation | Synchronization | Thread Communication</p> <p>Full Program 2</p> <p>Program 3: CPU Scheduling Algorithms</p> <p>Topics: FCFS | SJF | Round Robin</p> <p>Full Program 3</p> <p>Program 4: Shared Memory and IPC</p> <p>Topics: Shared Memory | Message Queues | Pipes | Semaphores</p> <p>Full Program 4</p> <p>Program 5: Dining Philosopher Problem</p> <p>Topics: Process Synchronization | Deadlock Avoidance | Semaphores</p> <p>Full Program 5</p> <p>Program 6: Producer-Consumer Problem</p> <p>Topics: Process Synchronization | Bounded Buffer | Semaphores</p> <p>Full Program 6</p> <p>Program 7: Readers-Writers Problem</p> <p>Topics: Process Synchronization | Priority Handling | Semaphores</p> <p>Full Program 7</p> <p>Program 8: Deadlock Detection</p> <p>Topics: Resource Allocation Graph | Wait-For Graph | Deadlock Detection Algorithm</p> <p>Full Program 8</p> <p>Program 9: Banker's Algorithm</p> <p>Topics: Deadlock Avoidance | Safety Algorithm | Resource Allocation</p> <p>Full Program 9</p> <p>Program 10: Page Replacement Algorithms (FIFO)</p> <p>Topics: FIFO | Page Faults | Optimal Reference String Handling</p> <p>Full Program 10</p> <p>Program 11: Page Replacement Algorithms (LRU &amp; LFU)</p> <p>Topics: LRU | LFU | Page Faults | Memory Optimization</p> <p>Full Program 11</p> <p>Program 12: Disk Scheduling (FCFS)</p> <p>Topics: Disk Scheduling | Seek Time | Head Movement</p> <p>Full Program 12</p> <p>Program 13: Disk Scheduling (SSTF)</p> <p>Topics: SSTF | Seek Time Reduction | Disk Optimization</p> <p>Full Program 13</p>"},{"location":"program1/","title":"Program 1: Unix System Calls","text":"<ul> <li>A system call is a programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on.</li> <li>A system call is a way for programs to interact with the operating system.</li> <li>System call provides the services of the operating system to the user programs via the Application Program Interface (API).</li> <li>System calls are the only entry points into the kernel system and are executed in kernel mode.</li> </ul>"},{"location":"program1/#fork","title":"Fork()","text":""},{"location":"program1/#theory","title":"Theory","text":"<ul> <li>The <code>fork()</code> system call in Unix/Linux is used to create a new child process by duplicating the parent process.</li> <li>The child process receives a copy of the parent\u2019s memory, file descriptors, and execution state.</li> <li>Both parent and child processes run the same program but have different process IDs.</li> <li>Return values of <code>fork()</code>:</li> <li>Negative value \u2192 Fork failed.</li> <li>Zero \u2192 Returned to the newly created child process.</li> <li>Positive value \u2192 Returned to the parent process (PID of the child).</li> <li>Number of processes = $2^n$, where <code>n</code> is the number of times fork is called.</li> <li>Number of child processes = $2^n - 1$.</li> </ul>"},{"location":"program1/#algorithm","title":"Algorithm","text":"<ol> <li>Declare variable <code>pid</code>.</li> <li>Call <code>fork()</code>.</li> <li>If <code>pid &lt; 0</code>, print <code>\"Fork failed\"</code>.</li> <li>If <code>pid == 0</code>, execute child process using <code>execlp()</code>.</li> <li>If <code>pid &gt; 0</code>, parent waits for child using <code>wait()</code>.</li> <li>Print <code>\"Child complete\"</code>.</li> </ol>"},{"location":"program1/#program","title":"Program","text":"<pre><code>//FORK\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main()\n{\n    int id, childid;\n    id = getpid(); // Get the process ID\n\n    if ((childid = fork()) &gt; 0) // Fork the process and check if it's the parent\n    {\n        printf(\"\\nI'm in the parent process %d\", getpid());\n    }\n    else if (childid == 0) // Check if it's the child process\n    {\n        printf(\"\\nI'm in the child process %d\", getpid());\n    }\n    else\n    {\n        printf(\"\\nFork failed!\");\n    }\n\n    return 0;\n} \n</code></pre>"},{"location":"program1/#factorial-using-fork","title":"Factorial Using Fork()","text":""},{"location":"program1/#algorithm_1","title":"Algorithm","text":"<ol> <li>Start.</li> <li>Input number <code>n</code>.</li> <li>Call <code>fork()</code>.</li> <li>If return value is <code>0</code> (child):</li> <li>Initialize <code>fact = 1</code>.</li> <li>Loop from 1 to <code>n</code>, compute factorial.</li> <li>Print result.</li> <li>If return value &gt; 0 (parent):</li> <li>Print <code>\"Child is calculating factorial\"</code>.</li> <li>End.</li> </ol>"},{"location":"program1/#program_1","title":"Program","text":"<pre><code>//FACTORIAL \n   #include &lt;stdio.h&gt;\n   #include &lt;unistd.h&gt;\n\n   int main() {\n       int n, i;\n       long long fact = 1;\n\n       printf(\"Enter a number: \");\n       scanf(\"%d\", &amp;n);\n\n       int pid = fork();\n\n       if (pid == 0) {\n           for (i = 1; i &lt;= n; i++) {\n               fact *= i;\n           }\n           printf(\"Child: Factorial of %d is %lld\\n\", n, fact);\n       } else {\n           printf(\"Parent: I created a child to calculate factorial.\\n\");\n       }\n       return 0;\n   }\n</code></pre>"},{"location":"program1/#process-hierarchy-using-fork","title":"Process Hierarchy using Fork()","text":""},{"location":"program1/#algorithm_2","title":"Algorithm","text":"<ul> <li>Call fork() \u2192 creates Process A.</li> <li>If return = 0:</li> <li>Print \"I am A\" with PID and PPID.</li> <li>Call fork() \u2192 create Process B.</li> <li>If return = 0:</li> <li>Print \"I am B\" with PID and PPID.</li> <li>Call fork() \u2192 create Process C.</li> <li>If return = 0:</li> <li>Print \"I am C\" with PID and PPID.</li> </ul>"},{"location":"program1/#program_2","title":"Program","text":"<pre><code>//HIERARCHY \n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    int pid;\n\n    pid = fork();  // Create process A\n\n    if (pid == 0) {\n        // This is Process A\n        printf(\"I am A (PID: %d), Parent: %d\\n\", getpid(), getppid());\n\n        int pid1 = fork();  // A creates B\n\n        if (pid1 == 0) {\n            // This is Process B\n            printf(\"I am B (PID: %d), Parent: %d\\n\", getpid(), getppid());\n\n            int pid2 = fork();  // B creates C\n\n            if (pid2 == 0) {\n                // This is Process C\n                printf(\"I am C (PID: %d), Parent: %d\\n\", getpid(), getppid());\n            }\n        }\n    }\n\n    return 0;\n} \n</code></pre>"},{"location":"program1/#wait","title":"Wait()","text":""},{"location":"program1/#theory_1","title":"Theory","text":"<ul> <li>The wait() system call is used by a parent process to pause execution until one of its child processes terminates.</li> <li>It helps:<ul> <li>Synchronize parent and child.</li> <li>Prevent zombie processes.</li> <li>Ensure parent waits for child to finish.</li> </ul> </li> </ul>"},{"location":"program1/#program_3","title":"Program","text":"<pre><code>// WAIT()\n\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;  // for wait()\n#include &lt;unistd.h&gt;    // for fork()\n\nint main() {\n    int i = 0, pid;\n\n    pid = fork();\n\n    if (pid == 0) {\n        // Child process\n        printf(\"Child process:\\n\");\n        for (i = 0; i &lt; 5; i++)\n            printf(\"%d\\n\", i);\n    } else {\n        // Parent process\n        wait(NULL);  // Wait for child to finish\n        printf(\"Parent process:\\n\");\n        for (i = 10; i &lt; 15; i++)\n            printf(\"%d\\n\", i);\n\n        printf(\"Process ends.\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"program1/#exec","title":"Exec()","text":""},{"location":"program1/#theory_2","title":"Theory","text":"<ul> <li>The exec family replaces the current running process with a new program.</li> <li>After a successful exec, the current process image is replaced and does not return.</li> </ul>"},{"location":"program1/#program_4","title":"Program","text":"<pre><code>//EXEC()\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n    printf(\"before execv\\n\");\n    execv(\"/bin/date\", argv);   // Replace process with date command\n    printf(\"after execv\\n\");    // Will not execute if execv is successful\n    return 0;\n}\n</code></pre>"},{"location":"program1/#sleep","title":"Sleep()","text":""},{"location":"program1/#theory_3","title":"Theory","text":"<ul> <li>The sleep() system call suspends execution of the process for a given number of seconds.</li> <li>Used to introduce delays in program execution.</li> </ul>"},{"location":"program1/#program_5","title":"Program","text":"<pre><code>// SLEEP \n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    printf(\"Program starts...\\n\");\n\n    printf(\"Sleeping for 5 seconds...\\n\");\n    sleep(5);   // process sleeps for 5 seconds\n\n    printf(\"Woke up after sleep!\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"unit1/","title":"Unit 1","text":""},{"location":"unit1/#data-vs-information","title":"Data vs Information","text":"Aspect Data Information Definition Raw, unprocessed facts and figures. Processed, organized, and meaningful data. Nature Unstructured or structured values. Structured and contextually relevant. Example A list of numbers: 23, 45, 67, 89 (without context). The average test score of students is 56%.\u009d Processing Requires processing to be useful. Already processed and meaningful. Storage in DBMS Stored as tables, records, and fields. Retrieved as reports, summaries, or insights. Usage Used as input for processing. Used for decision-making."},{"location":"unit1/#database-and-dbms","title":"Database and DBMS","text":"<ul> <li>A database is an organized collection of structured information, or data, typically stored electronically in a computer system</li> <li>It is the collection of interrelated data that is organised in a way that data can be easily accessed, managed and updated.</li> <li>It is designed to handle large amounts of structured information and supports various operations like querying, updating, and deleting data.</li> <li>Databases are managed using\u00a0Database Management Systems (DBMS), which provide an interface to interact with the data.</li> <li>The DBMS also handles tasks like backup, recovery, and query optimization to maintain the database\u2019s performance.</li> <li>Examples of databases include MySQL, PostgreSQL, MongoDB, and Oracle Database.</li> <li>Databases can store data in the form of tables depending upon the type of database.</li> </ul>"},{"location":"unit1/#types-of-databases","title":"Types of Databases","text":"<ul> <li>Relational Databases (RDBMS)\u00a0\u2013 Use tables with rows and columns (e.g: MySQL, PostgreSQL).</li> <li>NoSQL Databases\u00a0\u2013 Store data in flexible formats like key-value pairs, documents, or graphs (e.g: MongoDB, Redis).</li> <li>Cloud Databases\u00a0\u2013 Hosted on cloud platforms for scalability (e.g: Google BigQuery, Amazon RDS).</li> <li>Distributed Databases\u00a0\u2013 Spread across multiple locations for high availability (e.g: Apache Cassandra).</li> </ul>"},{"location":"unit1/#applications","title":"Applications","text":"<ol> <li>Railway and Airline Reservation Systems:<ul> <li>Manages ticket bookings, schedules, and delays.</li> </ul> </li> <li>Library Management System:<ul> <li>Tracks books, issue dates, authors, and availability.</li> </ul> </li> <li>Banking:<ul> <li>Handles transactions, account details, and fund transfers.</li> </ul> </li> <li>Educational Institutions:<ul> <li>Stores student records, results, and course details.</li> </ul> </li> <li>Credit Card Transactions:<ul> <li>Secures transaction history and cardholder data.</li> </ul> </li> <li>Social Media Platforms:<ul> <li>Stores user data, posts, and interactions.</li> </ul> </li> <li>Finance and Business:<ul> <li>Manages sales, investments, and financial statements.</li> </ul> </li> <li>Military:<ul> <li>Maintains highly secure defense-related data.</li> </ul> </li> <li>Online Shopping:<ul> <li>Stores product inventory, customer orders, and payments.</li> </ul> </li> <li>Human Resource Management:<ul> <li>Keeps track of employee details, salaries, and taxes.</li> </ul> </li> <li>Manufacturing and Supply Chain:<ul> <li>Manages production, inventory, and sales.</li> </ul> </li> </ol>"},{"location":"unit1/#characteristics-features","title":"Characteristics &amp; Features","text":"<ol> <li>Data Stored in Tables<ul> <li>Data is stored in tables with relationships between them, making it structured and meaningful.</li> </ul> </li> <li>Data Abstraction:<ul> <li>Hides complexity and provides a simplified view of data storage.</li> </ul> </li> <li>Data Independence<ul> <li>Schema changes do not affect applications accessing the data.</li> </ul> </li> <li>Reduced Redundancy<ul> <li>Uses\u00a0Normalization\u00a0to minimize data repetition, reducing storage costs and improving consistency.</li> </ul> </li> <li>Efficient Data Access<ul> <li>Database systems structure data using\u00a0predefined schemas and data models, allowing efficient\u00a0storage and retrieval.</li> <li>They\u00a0eliminate redundancy and anomalies\u00a0by enforcing constraints and rules, maintaining\u00a0data accuracy and reliability.</li> </ul> </li> <li>Support for Multiple Users and Concurrent Access <ul> <li>Multiple users\u00a0can\u00a0access and manipulate\u00a0data\u00a0simultaneously\u00a0while ensuring\u00a0data consistency\u00a0across applications.</li> <li>Supports\u00a0collaborative data sharing\u00a0without conflicts, making it easier for teams to work on shared datasets.</li> </ul> </li> <li>Query Language<ul> <li>Provides a simple query language like\u00a0SQL\u00a0for data retrieval, insertion, deletion, and updates.</li> </ul> </li> <li>Security <ul> <li>Database systems implement\u00a0strong security measures\u00a0to prevent\u00a0unauthorized access\u00a0and\u00a0protect sensitive data.</li> <li>Security mechanisms like\u00a0authentication, authorization, and encryption\u00a0help preserve\u00a0data confidentiality and privacy.</li> </ul> </li> <li>Data Integrity and Consistency <ul> <li>Ensures correctness and completeness using constraints like\u00a0primary keys, foreign keys, and unique constraints.</li> <li>Enforces\u00a0ACID (Atomicity, Consistency, Isolation, Durability)\u00a0properties to ensure\u00a0reliable transactions.</li> <li>Prevents inconsistencies by maintaining\u00a0referential integrity\u00a0and enforcing\u00a0business rules\u00a0through constraints.</li> </ul> </li> <li>Backup and Recovery <ul> <li>Provides\u00a0automatic data backups\u00a0and\u00a0transaction management\u00a0to safeguard data from\u00a0system crashes or failures.</li> <li>Ensures\u00a0data durability, meaning no data is lost even if a system failure occurs.</li> </ul> </li> <li>Data Sharing <ul> <li>Enables authorized users to access shared data as needed.</li> </ul> </li> <li>Scalability\u00a0&amp; Performance Optimization<ul> <li>Database systems are designed to handle\u00a0large volumes of data\u00a0efficiently, supporting\u00a0business growth and expansion.</li> <li>Indexing, query optimization, and caching improve\u00a0performance and speed\u00a0in retrieving information</li> </ul> </li> </ol>"},{"location":"unit1/#advantages","title":"Advantages","text":"<ol> <li>Data Redundancy Control\u00a0\u2013 Minimizes data duplication using\u00a0Normalization, ensuring efficient storage.</li> <li>Data Consistency\u00a0\u2013 Maintains data accuracy and prevents inconsistencies across multiple users.</li> <li>Improved Data Security\u00a0\u2013 Uses authentication, access control, and encryption to protect data.</li> <li>Data Integrity\u00a0\u2013 Enforces constraints like\u00a0primary keys and foreign keys\u00a0to maintain correctness.</li> <li>Concurrent Access &amp; Multi-User Support\u00a0\u2013 Allows multiple users to access and modify data simultaneously while ensuring\u00a0ACID properties.</li> <li>Backup &amp; Recovery\u00a0\u2013 Provides mechanisms to recover data in case of system failures or crashes.</li> <li>Efficient Data Retrieval\u00a0\u2013 Uses indexing, query optimization, and caching for faster data access.</li> <li>Standardized Query Language\u00a0\u2013 Supports\u00a0SQL\u00a0for easy data manipulation and retrieval.</li> <li>Scalability\u00a0\u2013 Can handle growing amounts of data efficiently.</li> <li>Data Sharing &amp; Centralized Management\u00a0\u2013 Enables multiple users to share data while maintaining control.</li> </ol>"},{"location":"unit1/#disadvantages","title":"Disadvantages","text":"<ol> <li>High Initial Cost\u00a0\u2013 Requires investment in hardware, software, and skilled personnel.</li> <li>Complexity\u00a0\u2013 Requires expertise to design, manage, and maintain databases efficiently.</li> <li>Performance Overhead\u00a0\u2013 Extra processing for security, integrity checks, and concurrency control can slow down operations.</li> <li>Failure Impact\u00a0\u2013 A database crash or corruption can lead to significant data loss if backups are not properly managed.</li> <li>Frequent Updates &amp; Maintenance\u00a0\u2013 Regular updates, tuning, and maintenance are necessary for smooth operation.</li> <li>Security Risks\u00a0\u2013 While DBMS provides security measures, improper configuration can make data vulnerable to attacks.</li> <li>Hardware &amp; Storage Requirements\u00a0\u2013 Large-scale databases require significant storage and powerful hardware.</li> </ol>"},{"location":"unit1/#tasks-in-dbms","title":"Tasks in DBMS","text":"<ul> <li>Data Definition\u00a0\u2013 Defines database structures, including tables, fields, and relationships using\u00a0Data Definition Language (DDL).</li> <li>Data Storage Management\u00a0\u2013 Efficiently stores and organizes data in tables.</li> <li>Data Manipulation\u00a0\u2013 Supports inserting, updating, deleting, and retrieving data using\u00a0Data Manipulation Language (DML).</li> <li>Data Retrieval\u00a0\u2013 Uses query languages like\u00a0SQL\u00a0to extract relevant information.</li> <li>Query Processing &amp; Optimization\u00a0\u2013 Executes and optimizes queries for faster data retrieval.</li> <li>Transaction Management\u00a0\u2013 Ensures\u00a0ACID properties\u00a0(Atomicity, Consistency, Isolation, Durability) for reliable transactions.</li> <li>Concurrency Control\u00a0\u2013 Manages multiple users accessing the database simultaneously without conflicts.</li> <li>Data Security &amp; Access Control\u00a0\u2013 Prevents unauthorized access through authentication, user permissions, and encryption.</li> <li>Data Integrity Enforcement\u00a0\u2013 Ensures correctness using constraints like\u00a0primary keys, foreign keys, and unique constraints.</li> <li>Backup and Recovery\u00a0\u2013 Provides data recovery options in case of system failures or corruption.</li> <li>Data Redundancy Control\u00a0\u2013 Minimizes duplicate data through\u00a0Normalization\u00a0techniques.</li> <li>Indexing &amp; Performance Tuning\u00a0\u2013 Uses indexing and optimization techniques for faster data retrieval.</li> <li>Logging &amp; Monitoring\u00a0\u2013 Keeps logs of database activities and monitors performance for maintenance.</li> <li>Improved Data Sharing\u00a0\u2013 Enables multiple users to access and share data efficiently while maintaining security and consistency.</li> </ul>"},{"location":"unit1/#file-system-approach","title":"File System Approach","text":"<p>The\u00a0File System Approach\u00a0is a traditional method of storing and managing data in files on a storage device without a centralized database management system (DBMS). It relies on operating system file-handling mechanisms to store, retrieve, and manipulate data</p>"},{"location":"unit1/#characteristics","title":"Characteristics","text":"<ol> <li>Data is Stored in Files\u00a0\u2013 Each application has its own set of files, and data is stored in separate text or binary files.</li> <li>Manual Data Management\u00a0\u2013 Users and applications must manually handle data access, retrieval, and updates.</li> <li>Limited Data Sharing\u00a0\u2013 Data is difficult to share between applications due to lack of standardization.</li> <li>No Centralized Control\u00a0\u2013 Each file is managed separately without a common structure.</li> <li>Data Redundancy &amp; Inconsistency\u00a0\u2013 The same data may be duplicated in multiple files, leading to inconsistencies</li> </ol>"},{"location":"unit1/#disadvantages_1","title":"Disadvantages","text":"<ol> <li>Data Redundancy\u00a0\u2013 Duplicate data in multiple files wastes storage space.</li> <li>Data Inconsistency\u00a0\u2013 Changes in one file may not be reflected in others, leading to mismatches.</li> <li>Lack of Security\u00a0\u2013 No built-in authentication or access control mechanisms.</li> <li>Difficult Data Retrieval\u00a0\u2013 Searching for specific data requires manual or programmatic effort.</li> <li>Concurrency Issues\u00a0\u2013 Multiple users accessing the same file can cause conflicts and data corruption.</li> <li>No ACID Properties\u00a0\u2013 Transactions are not managed properly, leading to data integrity issues.</li> <li>Difficult Backup &amp; Recovery\u00a0\u2013 Manual backups are required, and recovering lost data is complex.</li> </ol>"},{"location":"unit1/#advantages_1","title":"Advantages","text":"<ol> <li>Simple &amp; Easy to Use\u00a0\u2013 Requires no complex setup; files can be created and managed easily.</li> <li>Low Cost\u00a0\u2013 No need for expensive database software; works with basic operating system tools.</li> <li>Faster for Small-Scale Applications\u00a0\u2013 Works well for small tasks where a full\u00a0DBMS\u00a0is unnecessary.</li> <li>No Overhead\u00a0\u2013 No extra processing for security, transaction management, or query optimization.</li> <li>Efficient for Specific Tasks\u00a0\u2013 Useful for storing logs, configuration files, or temporary data.</li> <li>Less Hardware Requirement\u00a0\u2013 Does not require high-end hardware or large storage capacity.</li> <li> <p>Customizable\u00a0\u2013 Developers can structure and manage files according to specific application needs.</p> FILE SYSTEM INTERFACE DBMS INTERFACE End User End User Application Programs Application Programs Interface through high lvl language Interface through Query OS DBMS Disk Storage (FS) OS Disk Storage (DB) </li> </ol> Feature FSA DBMS Data Storage Data is stored in separate files manually. Data is stored in a structured format using tables. Data Redundancy High redundancy due to duplicate data in multiple files. Minimizes redundancy through\u00a0Normalization. Data Consistency Low consistency as changes in one file may not reflect in others. Ensures consistency with constraints and\u00a0ACID properties. Data Integrity No built-in integrity constraints. Uses\u00a0primary keys, foreign keys, and constraints for data accuracy. Security No authentication or access control. Provides\u00a0user authentication, permissions, and encryption. Data Sharing Difficult to share data across applications. Multiple users and applications can easily share data. Concurrency Control No mechanism to handle multiple users accessing the same file. Uses\u00a0locking, transactions, and\u00a0ACID properties\u00a0for safe concurrent access. Data Retrieval Requires manual searching or custom programming. Supports\u00a0SQL\u00a0for fast and efficient data retrieval. Backup &amp; Recovery Manual backup; data recovery is complex. Automated\u00a0backup and recovery\u00a0mechanisms available. Scalability Limited scalability; performance degrades with data growth. Highly scalable; efficiently handles large amounts of data. Cost Low initial cost; does not require additional software. High setup cost due to software, hardware, and management. Complexity Simple and easy to use. More complex but provides advanced features."},{"location":"unit1/#view-of-data","title":"View of Data","text":"<p>Schema:\u00a0The overall design of the database is called schema</p> <p>For example - In a program we do variable declaration and assignment of values to the variable. The variable declaration is called schema and the value assigned to the variable is called instance. The schema for the student record can be</p> Roll No Name Marks <p>Instances:\u00a0When information is inserted or deleted from the database then the database gets changed. The collection of information at particular moment is called instances. For example - following is an instance of student database</p> Roll No Name Marks 10 AAA 43 20 BBB 67 <p>Types of Schema:\u00a0The database has several schema based on the levels of abstraction.</p> <p>(1) Physical Schema:\u00a0The physical schema is a database design described at the physical level of abstraction.</p> <p>(2) Logical Schema:\u00a0The logical schema is a database design at the logical level of abstraction.</p> <p>(3) Subschema:A database may have several views at the view level which are called\u00a0subschemas.</p>"},{"location":"unit1/#data-abstraction","title":"Data Abstraction","text":"<p>Data abstraction in DBMS refers to the process of hiding unnecessary details from end users while providing only the relevant data. Database systems involve complex data structures and relationships, but data abstraction ensures that users interact with data without needing to understand these complexities.</p>"},{"location":"unit1/#levels-of-data-abstraction","title":"Levels of Data Abstraction","text":"<ol> <li>Physical Level (Internal Level)</li> <li>Lowest level of abstraction.</li> <li>Defines how data is stored using data structures, indexing, and access methods.</li> <li>Concerned with database performance, optimization, and storage mechanisms.</li> <li>Example:<ul> <li>A customer\u2019s information is stored in tables, but at the physical level, it is managed as data blocks.</li> <li>Indexed file organization allows record retrieval using indexes, while sequential file organization stores records in a continuous manner.</li> </ul> </li> <li>Logical Level (Conceptual Level)</li> <li>Middle level of abstraction.</li> <li>Defines what data is stored and the relationships between them.</li> <li>Represents entities, attributes, and relationships among tables.</li> <li>Less complex than the physical level but still requires knowledge of the database schema.</li> <li>Example:<ul> <li>A table\u00a0\"Students\"\u00a0with attributes\u00a0student_name, roll_no, student_ID, and marks.</li> <li>A table\u00a0\"Teachers\"\u00a0containing teacher_ID, address, and linked student_IDs (foreign key).</li> </ul> </li> <li>View Level (External Level)</li> <li>Highest level of abstraction.</li> <li>Provides different views of the database for different users, showing only relevant data.</li> <li>Facilitates interaction with the database using Graphical User Interfaces (GUIs).</li> <li>Example:<ul> <li>A teacher\u2019s view of a student database may show\u00a0student names and marks, while an admin may access\u00a0fees and attendance records.</li> </ul> </li> </ol>"},{"location":"unit1/#features-of-data-abstraction","title":"Features of Data Abstraction","text":"<p>1. Multiple Levels of Abstraction</p> <p>DBMS provides three levels of abstraction:</p> <ul> <li>External Level (View Level):\u00a0Users see only the relevant part of the database without needing to know its internal structure.</li> <li>Conceptual Level (Logical Level):\u00a0Defines the structure and relationships of data without focusing on physical storage.</li> <li>Internal Level (Physical Level):\u00a0Deals with the actual storage of data in memory and databases.</li> </ul> <p>2. Separation of Concerns</p> <ul> <li>Different users (end users, database designers, and administrators) can interact with the database at different abstraction levels.</li> <li>Ensures that logical design and physical storage are independent, simplifying database management.</li> </ul> <p>3. Mapping Between Levels</p> <ul> <li>Provides a structured way to link different abstraction levels, ensuring changes at one level do not affect others.</li> <li>Example: A change in storage structure at the physical level does not affect the conceptual or external levels.</li> </ul> <p>4. Data Independence</p> <ul> <li>Logical Data Independence:\u00a0Changes in the logical structure do not impact external views.</li> <li>Physical Data Independence:\u00a0Changes in storage methods do not affect logical schema.</li> </ul> <p>5. Transparency </p> <ul> <li>Hides complex implementation details, providing a simplified and consistent view of data to users.</li> <li>Users can retrieve and manipulate data without knowing its actual storage or retrieval mechanisms.</li> </ul> <p>6. Security and Controlled Access</p> <ul> <li>Restricts access to sensitive data by defining different views for different users.</li> <li>Ensures that unauthorized users cannot see or modify restricted information.</li> </ul> <p>7. Enhanced Maintainability &amp; Flexibility</p> <ul> <li>Simplifies updates, modifications, and scaling of the database.</li> <li>Reduces the impact of structural changes on users and applications.</li> </ul>"},{"location":"unit1/#advantages-of-data-abstraction","title":"Advantages of Data Abstraction","text":"<p>Simplifies User Interaction</p> <p>\u2013 Users do not need to understand storage complexities.</p> <p>Improves Security</p> <p>\u2013 Sensitive data is hidden, ensuring restricted access.</p> <p>Reduces Complexity</p> <p>\u2013 Users work with simplified views, while DBMS handles complex operations.</p> <p>Increases Flexibility</p> <p>\u2013 Structural changes in the database do not affect user experience.</p> <p>Enhances Data Integrity</p> <p>\u2013 Ensures consistent and correct data storage.</p>"},{"location":"unit1/#data-independance","title":"Data Independance","text":"<p>Data Independence\u00a0refers to the ability to modify a database schema at one level without affecting the schema at the next higher level. It ensures that changes in storage, structure, or organization do not impact the way users interact with data. This is one of the key characteristics of a\u00a0(DBMS)\u00a0as it helps in managing large amounts of data efficiently and ensures adaptability over time.</p> <p></p> <p>Importance of Data Independence:</p> <ul> <li>A database contains vast amounts of data that must be frequently updated to meet changing requirements.</li> <li>A\u00a0multi-layer architecture\u00a0is used in DBMS to ensure that modifications at one level do not affect other levels.</li> <li>The\u00a0three levels of abstraction\u2014Physical Level, Logical Level, and View Level\u2014help achieve data independence.</li> <li>Data independence improves maintainability, flexibility, security, and cost-effectiveness in database management.</li> </ul>"},{"location":"unit1/#physical-data-independence","title":"Physical Data Independence","text":"<p>Physical data independence is the ability to modify the\u00a0physical schema\u00a0(how and where data is stored) without affecting the\u00a0logical schema\u00a0(conceptual structure) or the\u00a0view level\u00a0(user interactions).</p> <p>Key Aspects:</p> <ul> <li>Changes in storage structure, indexing methods, or hardware do not require changes in the database schema or applications.</li> <li>Helps in optimizing storage and improving performance without impacting user accessibility.</li> </ul> <p>Examples:</p> <ol> <li>Changing from one data structure to another (e.g., switching from B-trees to hash indexes).</li> <li>Using a new storage technology, such as moving from HDDs to SSDs or cloud storage.</li> <li>Changing the location of database files from one drive to another.</li> <li>Modifying the database file organization (e.g., partitioning tables for faster queries).</li> </ol>"},{"location":"unit1/#logical-data-independence","title":"Logical Data Independence","text":"<p>Logical data independence is the ability to modify the\u00a0logical schema\u00a0(organization, structure, or relationships of data) without affecting the\u00a0external schema\u00a0(user views and application programs).</p> <p>Key Aspects:</p> <ul> <li>Ensures that applications remain unaffected by changes in data structure.</li> <li>Compared to physical data independence,\u00a0logical data independence is harder to achieve\u00a0because changes in relationships or attributes might require modifications in queries and reports.</li> </ul> <p>Examples:</p> <ol> <li>Adding, modifying, or deleting an attribute, entity, or relationship without rewriting existing application programs.</li> <li>Merging two tables into one or splitting an existing table into multiple tables.</li> <li>Changing constraints or data types of existing attributes without affecting user interactions</li> </ol> Feature PDI LDI Definition Changes in physical storage do not affect logical structure. Changes in logical structure do not affect user views or applications. Affects Storage structures, file organization, indexing. Database schema, tables, attributes, relationships. Ease of Implementation Easier to achieve. Harder to achieve. Ease of Retrieving we can retrieve it easily retrieving is very difficult because the data mainly depends on its logical structure not its physical location Types of Schema the internal schema is the primary concern the conceptual schema is the primary concern Examples Changing storage devices, file locations. Adding new attributes, splitting tables."},{"location":"unit1/#ef-codd-rules","title":"EF Codd Rules","text":"<p>Dr.\u00a0Edgar F. Codd, a computer scientist, proposed a set of\u00a012 rules\u00a0(plus Rule 0) to define what qualifies as a\u00a0Relational Database Management System (RDBMS). These rules ensure\u00a0data integrity, consistency, usability, and independence\u00a0in database management</p> <ul> <li> <p>Rule 0: The Foundation Rule</p> <ul> <li>A database must be structured in a\u00a0relational manner, and its management should be entirely based on\u00a0relational capabilities\u00a0to be considered an RDBMS.</li> </ul> </li> <li> <p>Rule 1: The Information Rule</p> <ul> <li>All\u00a0data and metadata\u00a0(information about the database) must be stored in tables as values within cells.</li> <li>The entire database should follow a\u00a0tabular format\u00a0to maintain consistency.</li> </ul> </li> <li>Rule 2: The Guaranteed Access Rule<ul> <li>Each data item must be accessible using a\u00a0combination of table name, primary key (row identifier), and attribute name (column identifier).</li> <li>This ensures that no data is left inaccessible.</li> </ul> </li> <li>Rule 3: Systematic Treatment of NULL Values<ul> <li>NULL values\u00a0(representing missing or unknown data) should be handled uniformly across the system.</li> <li>NULL should be\u00a0distinct\u00a0from blank spaces or zero values.</li> </ul> </li> <li>Rule 4: Active Online Catalog Rule<ul> <li>Metadata (information about database structure) should be\u00a0stored within the database itself\u00a0as tables.</li> <li>Users should be able to query this catalog using the same language (e.g., SQL) used for regular data queries.</li> </ul> </li> <li> <p>Rule 5: The Comprehensive Data Sublanguage Rule</p> <p>The database should support a single, well-defined language (such as SQL) for:</p> <ul> <li>Data Definition (DDL)\u00a0\u2013 Creating and modifying tables.</li> <li>Data Manipulation (DML)\u00a0\u2013 Querying, inserting, updating, and deleting records.</li> <li>Access Control\u00a0\u2013 Managing security and authorization.</li> </ul> </li> <li> <p>Rule 6: The View Updating Rule</p> <ul> <li>A\u00a0view\u00a0(a virtual table based on query results) should be updatable if it is\u00a0theoretically possible\u00a0to do so.</li> <li>This ensures\u00a0data consistency\u00a0when using views.</li> </ul> </li> <li>Rule 7: High-level Insert, Update, and Delete<ul> <li>The system should allow\u00a0set-level operations, meaning users can\u00a0insert, update, or delete multiple rows\u00a0at once using a single query.</li> <li>This improves\u00a0efficiency and usability.</li> </ul> </li> <li>Rule 8: Physical Data Independence<ul> <li>Changes in\u00a0physical storage structures\u00a0(e.g., moving data to different disks)\u00a0should not affect applications\u00a0that access the database.</li> <li>This ensures\u00a0hardware flexibility\u00a0without disrupting the system.</li> </ul> </li> <li>Rule 9: Logical Data Independence<ul> <li>Changes in the\u00a0logical schema\u00a0(e.g., adding/modifying tables or columns)\u00a0should not require changes in application programs.</li> <li>This makes the system more\u00a0adaptable\u00a0to future modifications.</li> </ul> </li> <li>Rule 10: Integrity Independence<ul> <li>Integrity constraints\u00a0(such as\u00a0primary keys, foreign keys, and unique constraints) must be\u00a0defined separately from applications\u00a0and stored within the database catalog.</li> <li>These constraints should be\u00a0enforced automatically\u00a0by the system.</li> </ul> </li> <li>Rule 11: Distribution Independence<ul> <li>Whether the database is\u00a0centralized or distributed across multiple locations, it should behave the\u00a0same way\u00a0for users.</li> <li>Distribution should be\u00a0transparent, meaning users don\u2019t need to know where the data is physically stored.</li> </ul> </li> <li>Rule 12: Non-Subversion Rule<ul> <li>The system should prevent users from\u00a0bypassing security and integrity constraints\u00a0through low-level access methods (e.g., file handling).</li> <li>Even if a system provides direct access to records,\u00a0security measures must not be compromised.</li> </ul> </li> </ul>"},{"location":"unit1/#db-languages","title":"DB: Languages","text":"<p>Database languages are used to create, manipulate, retrieve, and manage data in a\u00a0Database Management System (DBMS). The main types of database languages are:</p> <p>1. Data Definition Language (DDL)</p> <ul> <li>Used to\u00a0define and modify\u00a0the database structure.</li> <li> <p>Includes commands for\u00a0creating, altering, and deleting\u00a0tables and schemas.</p> Command Description <code>CREATE</code> Creates a new database, table, or view <code>ALTER</code> Modifies an existing database structure <code>DROP</code> Deletes a database, table, or column <code>TRUNCATE</code> Removes all records from a table without deleting its structure <pre><code>CREATE TABLE Employees (\n    EmployeeID INT PRIMARY KEY,\n    Name VARCHAR(50),\n    Age INT,\n    Department VARCHAR(50)\n);\n\nALTER TABLE Employees ADD Salary DECIMAL(10,2);\n\nDROP TABLE Employees;\n\nTRUNCATE TABLE Employees;\n</code></pre> </li> </ul> <p>2. Data Manipulation Language (DML)</p> <ul> <li>Used to\u00a0retrieve and manipulate\u00a0data stored in the database.</li> <li>Allows\u00a0insertion, deletion, modification, and retrieval\u00a0of data.</li> </ul> Command Description <code>SELECT</code> Retrieves data from a database <code>INSERT</code> Adds new data to a table <code>UPDATE</code> Modifies existing records in a table <code>DELETE</code> Removes records from a table <p>Types of DML:</p> <ul> <li>Procedural DML\u00a0\u2013 Requires the user to specify\u00a0how\u00a0to retrieve data.</li> <li> <p>Non-Procedural DML\u00a0\u2013 Requires the user to specify\u00a0what\u00a0data to retrieve, letting the system handle retrieval (e.g., SQL).</p> <pre><code>SELECT Name, Age FROM Employees WHERE Department = 'HR';\n\nINSERT INTO Employees (EmployeeID, Name, Age, Department, Salary) \nVALUES (101, 'Alice', 30, 'IT', 50000.00);\n\nUPDATE Employees SET Salary = 55000.00 WHERE EmployeeID = 101;\n</code></pre> </li> </ul> <p>3. Data Control Language (DCL)</p> <ul> <li>Used to\u00a0control user access\u00a0to the database.</li> <li> <p>Ensures\u00a0security and authorization\u00a0for database operations.</p> Command Description <code>GRANT</code> Gives users permissions to perform database operations <code>REVOKE</code> Removes permissions from a user <pre><code>GRANT SELECT, INSERT ON Employees TO user1;\n\nREVOKE INSERT ON Employees FROM user1;\n</code></pre> </li> </ul> <p>4. Transaction Control Language (TCL)</p> <ul> <li>Used to\u00a0manage transactions\u00a0in a database to ensure\u00a0consistency and integrity.</li> <li> <p>Helps in\u00a0rollback, commit, and savepoint\u00a0operations.</p> Command Description <code>COMMIT</code> Saves all changes made by the transaction permanently <code>ROLLBACK</code> Reverts all changes made in the current transaction <code>SAVEPOINT</code> Creates a checkpoint in a transaction, allowing partial rollbacks <pre><code>BEGIN TRANSACTION;\nUPDATE Employees SET Salary = 60000 WHERE EmployeeID = 101;\nCOMMIT;\n\nBEGIN TRANSACTION;\nUPDATE Employees SET Salary = 65000 WHERE EmployeeID = 101;\nROLLBACK;\n\nBEGIN TRANSACTION;\nUPDATE Employees SET Salary = 60000 WHERE EmployeeID = 101;\nSAVEPOINT BeforeRaise;\nUPDATE Employees SET Salary = 65000 WHERE EmployeeID = 101;\nROLLBACK TO BeforeRaise;\n</code></pre> </li> </ul>"},{"location":"unit1/#db-design-process","title":"DB: Design Process","text":"<ul> <li>The\u00a0database design process\u00a0is a structured approach to developing a\u00a0Database Management System (DBMS)\u00a0that ensures\u00a0efficient data storage, retrieval, integrity, and security.</li> <li>A well-designed database meets user requirements while maintaining\u00a0scalability, performance, and reliability.</li> <li>The database design process consists of several\u00a0phases, each playing a crucial role in ensuring the success of the database application.By following these phases:</li> <li>Requirement Collection &amp; Analysis\u00a0\u2013 Gather user needs.</li> <li>Conceptual Design\u00a0\u2013 Create ER models.</li> <li>Logical Design\u00a0\u2013 Convert to relational schema.</li> <li>Physical Design\u00a0\u2013 Optimize storage and indexing.</li> <li>Implementation &amp; Data Loading\u00a0\u2013 Create and populate the database.</li> <li>Testing &amp; Evaluation\u00a0\u2013 Ensure functionality and performance.</li> <li>Maintenance &amp; Optimization\u00a0\u2013 Continuously monitor and improve.</li> </ul> <p>1. Requirement Collection and Analysis Phase</p> <p>This phase involves gathering detailed\u00a0user and functional requirements\u00a0for the database.</p> <p>Key Activities:</p> <ul> <li>Conduct\u00a0interviews\u00a0and\u00a0meetings\u00a0with prospective users to understand their needs.</li> <li>Identify\u00a0data flow, user operations, transaction frequency, and security requirements.</li> <li>Document requirements using\u00a0diagrams\u00a0such as:<ul> <li>Sequence Diagrams\u00a0(User interactions)</li> <li>Data Flow Diagrams (DFDs)\u00a0(Data movement)</li> <li>Use Case Scenarios\u00a0(Real-world use cases)</li> </ul> </li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0comprehensive requirements document\u00a0that serves as the foundation for database design.</li> <li>Defines the\u00a0functional scope\u00a0of the database.</li> <li>This phase plays a\u00a0vital role\u00a0in the success of the database and ensures that\u00a0all stakeholder needs\u00a0are accounted for.</li> </ul> <p>2. Conceptual Design Phase</p> <p>In this phase, a\u00a0conceptual schema\u00a0is developed to represent the\u00a0overall structure of the database\u00a0without focusing on technical implementation details.</p> <p>Key Activities:</p> <ul> <li>Select an appropriate\u00a0data model\u00a0(e.g.,\u00a0Entity-Relationship (ER) Model).</li> <li>Identify\u00a0entities, attributes, relationships, and constraints.</li> <li>Represent the data using an\u00a0ER diagram.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0high-level conceptual schema\u00a0that ensures all user requirements are met without conflicts.</li> <li>The design remains\u00a0independent of any specific RDBMS\u00a0(e.g., MySQL, PostgreSQL).</li> <li>Acts as a\u00a0communication tool\u00a0between designers and end users.</li> </ul> <p>3. Logical Design Phase</p> <p>This phase translates the\u00a0conceptual schema\u00a0into a\u00a0relational schema\u00a0that can be implemented in an RDBMS.</p> <p>Key Activities:</p> <ul> <li>Convert\u00a0ER diagrams\u00a0into\u00a0tables, attributes, primary keys (PK), and foreign keys (FK).</li> <li>Define\u00a0constraints\u00a0(e.g.,\u00a0<code>NOT NULL</code>,\u00a0<code>UNIQUE</code>,\u00a0<code>CHECK</code>) to ensure data integrity.</li> <li>Normalize data to remove redundancy and improve consistency.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0relational schema\u00a0that is\u00a0structured and optimized\u00a0for efficient data operations.</li> <li>Provides a\u00a0detailed framework\u00a0for physical database implementation.</li> </ul> <p>Example:</p> Student Table Course Table Enrollment Table Student_ID (PK) Course_ID (PK) Student_ID (FK) Name Course_Name Course_ID (FK) Age <p>4. Physical Design Phase</p> <p>In this phase, technical\u00a0decisions about storage and performance optimization\u00a0are made.</p> <p>Key Activities:</p> <ul> <li>Define\u00a0storage structures, indexing, partitioning, and file organization.</li> <li>Optimize for\u00a0performance, scalability, and security.</li> <li>Choose\u00a0appropriate database servers and application environments.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0physical design specification\u00a0that includes:<ul> <li>Database\u00a0storage architecture.</li> <li>Indexing strategies to\u00a0improve query performance.</li> <li>Security configurations and\u00a0access control policies.</li> </ul> </li> </ul> <p>5. Implementation and Data Loading Phase</p> <p>This phase involves the\u00a0creation of the database\u00a0and\u00a0loading of data.</p> <p>Key Activities:</p> <ul> <li>Implement the database using\u00a0SQL DDL (Data Definition Language) commands.</li> <li>Populate tables manually or automatically by\u00a0migrating data from an existing system.</li> <li>Configure\u00a0database security and user roles.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0fully operational database\u00a0with initial data loaded.</li> <li>Ready for\u00a0testing and validation.</li> </ul> <p>Example:</p> <pre><code>sql\nCopyEdit\nCREATE TABLE Student (\n    Student_ID INT PRIMARY KEY,\n    Name VARCHAR(50),\n    Age INT\n);\n\nINSERT INTO Student VALUES (1, 'Alice', 20);\n</code></pre> <p>6. Testing and Evaluation Phase</p> <p>This phase ensures that the database performs correctly and meets\u00a0functional and non-functional requirements.</p> <p>Key Activities:</p> <ul> <li>Test\u00a0data integrity, concurrency, security, and performance.</li> <li>Optimize database queries for\u00a0efficiency.</li> <li>Identify issues and apply\u00a0modifications if needed\u00a0(e.g., improving indexing, adjusting constraints).</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0fully optimized\u00a0and\u00a0functional\u00a0database system.</li> <li>Any performance issues or security risks are addressed before deployment.</li> </ul> <p>Example:</p> <ul> <li>Testing whether a user can register for a\u00a0non-existent course:</li> </ul> <pre><code>SELECT * FROM Enrollment WHERE Course_ID NOT IN (SELECT Course_ID FROM Course);\n</code></pre> <p>7. Maintenance and Optimization Phase</p> <p>This phase ensures the database remains\u00a0efficient, secure, and up to date\u00a0over time.</p> <p>Key Activities:</p> <ul> <li>Regular\u00a0monitoring and performance tuning.</li> <li>Implement\u00a0backup and recovery plans\u00a0to prevent data loss.</li> <li>Modify the schema if\u00a0business requirements change.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0reliable and well-maintained database\u00a0that continues to perform efficiently.</li> <li>Security vulnerabilities and performance bottlenecks are periodically addressed.</li> </ul>"},{"location":"unit1/#db-architecture","title":"DB: Architecture","text":"<ul> <li>The DBMS design depends upon its architecture. The basic client/server architecture is used to deal with a large number of PCs, web servers, database servers and other components that are connected with networks.</li> <li>The client/server architecture consists of many PCs and a workstation which are connected via the network.</li> <li>DBMS architecture depends upon how users are connected to the database to get their request done.</li> </ul>"},{"location":"unit1/#1-tier","title":"1 Tier","text":"<p>In\u00a01-Tier Architecture, the database, client, and server are all located on the same machine. This architecture allows the user to directly interact with the database, making it suitable for personal or standalone applications.</p> <p></p> <ul> <li>Example: Microsoft Excel\u00a0is a one-tier system where data is stored and processed on the same computer.</li> </ul> <p>Features</p> <ul> <li>All-in-One System: The user interface (UI), application logic, and data are all managed on the same machine.</li> <li>No External Network or Server Connection: Everything is self-contained, requiring no external connections.</li> </ul> <p>Advantages</p> <p>\u2714\u00a0Simple Setup\u00a0\u2013 Only one machine is needed.</p> <p>\u2714\u00a0Cost-Effective\u00a0\u2013 No need for additional hardware or network infrastructure.</p> <p>\u2714\u00a0Easy Deployment\u00a0\u2013 Ideal for small projects with minimal setup requirements</p>"},{"location":"unit1/#2-tier","title":"2 Tier","text":"<p>The 2-Tier Architecture follows a client-server model, where the client directly communicates with the database server using APIs like ODBC/JDBC. The server handles query processing and transaction management, while the client runs the user interface and application logic.</p> <p></p> <ul> <li> <p>Example: Library Management System</p> <ol> <li> <p>Client Layer (Tier 1) \u2013 A desktop application used to search books, issue them, and check due dates.</p> </li> <li> <p>Database Layer (Tier 2) \u2013 Stores all book records, user information, and transaction logs.</p> </li> </ol> <p>When a user searches for a book, the client sends a request to the database, which processes the query and returns the result.</p> </li> </ul> <p>Advantages</p> <p>\u2714 Faster Access \u2013 Direct communication speeds up query execution.</p> <p>\u2714 Scalability \u2013 Easy to add clients or upgrade hardware.</p> <p>\u2714 Low Cost \u2013 More affordable than 3-tier and multi-tier architectures.</p> <p>\u2714 Easy Deployment \u2013 Simple to set up compared to 3-tier systems.</p>"},{"location":"unit1/#3-tier","title":"3 Tier","text":"<p>In 3-Tier Architecture, an additional application server sits between the client and database, acting as an intermediary. The client does not directly communicate with the database, improving security and scalability.</p> <p></p> <p>Example: E-Commerce Store</p> <ol> <li> <p>Client (User) \u2013 Searches for a product and adds it to the cart.</p> </li> <li> <p>Application Server (Processing) \u2013 Checks product availability, applies discounts, and calculates the total price.</p> </li> <li> <p>Database Server \u2013 Stores product details, order history, and user information.</p> </li> </ol> <p>Advantages</p> <p>\u2714 Enhanced Scalability \u2013 Distributes workload, reducing direct database connections.</p> <p>\u2714 Data Integrity \u2013 The middle layer prevents data corruption and enhances consistency.</p> <p>\u2714 Improved Security \u2013 Restricts direct access to the database, reducing unauthorized data access.</p> <p>Disadvantages</p> <p>\u2716 Increased Complexity \u2013 More components mean higher setup and maintenance costs.</p> <p>\u2716 Slower Interaction \u2013 Additional layers increase processing time.</p>"},{"location":"unit1/#dbs-architure","title":"DBS: Architure","text":""},{"location":"unit1/#system-users","title":"System Users","text":"<p>A database system has four primary types of users:</p> <p>1. Naive Users</p> <ul> <li>Unsophisticated users who interact with the system through pre-written application programs.</li> <li>Example: A ticket booking clerk using a reservation system.</li> </ul> <p>2. Application Developers</p> <ul> <li>Responsible for creating software applications that interact with the database.</li> <li>Develop APIs to facilitate communication between applications and the database.</li> </ul> <p>3. Sophisticated Users</p> <ul> <li>Interact with the database without writing programs.</li> <li>Use database query languages to form requests.</li> <li>Their queries are processed by the query processor, which translates high-level DML statements into instructions understood by the storage manager.</li> </ul> <p>4. Database Administrator (DBA)</p> <ul> <li>The DBA is responsible for managing and maintaining the database system.Key Role of DMA<ol> <li>Database Installation &amp; Configuration</li> <li>Set up database software, parameters, file structures, and security settings.</li> <li>Backup &amp; Recovery</li> <li>Ensure regular backups and implement a disaster recovery plan.</li> <li>Security Management</li> <li>Set up user accounts, define access permissions, and encrypt sensitive data.</li> <li>Performance Tuning</li> <li>Optimize database schema, tune queries, and manage system resources (memory, CPU, storage).</li> <li>Maintenance &amp; Upgrades</li> <li>Perform tasks like index optimization, defragmentation, and database migrations.</li> </ol> </li> </ul> <p>The functional components of a DBMS can be broadly divided into:</p> <ol> <li> <p>Query Processor</p> </li> <li> <p>Storage Manager</p> </li> </ol>"},{"location":"unit1/#query-processor","title":"Query Processor","text":"<ul> <li>The query processor is responsible for interpreting and executing user queries.</li> <li>It transforms high-level queries (SQL) into low-level operations that the database engine can execute.</li> </ul> <p>Functions of the Query Processor</p> <ul> <li>Simplifies data access for users.</li> <li>Users do not need to understand the system\u2019s physical implementation.</li> <li>Ensures quick query processing and updates.</li> </ul> <p>Query Processor Components</p> <p>1. DDL Interpreter</p> <ul> <li>Processes Data Definition Language (DDL) statements.</li> <li>Handles commands for creating, modifying, and deleting database structures (tables, indexes, views, constraints).</li> </ul> <p>2. DML Compiler &amp; Organizer</p> <ul> <li>Processes Data Manipulation Language (DML) statements such as INSERT, UPDATE, DELETE, and SELECT.</li> <li>Converts high-level DML queries into low-level database operations.</li> <li>DML Compiler: Translates DML queries into executable instructions.</li> <li>DML Organizer: Executes the compiled query plan.</li> </ul> <p>3. Application Program Object Code (APOC)</p> <ul> <li>Compiled version of an application program that interacts with the database.</li> <li>Converts source code into machine-readable form.</li> </ul> <p>4. Compiler &amp; Linker</p> <ul> <li>Application programmers write source code.</li> <li>The compiler and linker process this code, linking it to DML queries before execution.</li> </ul> <p>5. Query Evaluation Engine</p> <ul> <li>Executes user queries and retrieves the requested data.Key Functions:</li> <li>Query Parsing &amp; Validation: Ensures correct syntax.</li> <li>Query Optimization: Determines the most efficient way to execute a query.</li> <li>Query Plan Generation: Creates an execution plan based on optimization.</li> <li>Data Retrieval &amp; Manipulation: Interacts with the storage manager to fetch data efficiently.</li> <li>Concurrency Control &amp; Transaction Management: Ensures data consistency in a multi-user environment.</li> <li>Result Formatting &amp; Delivery: Formats query results for the user.</li> </ul>"},{"location":"unit1/#data-storage-manager","title":"Data Storage Manager","text":"<ul> <li>Data Storage Manager also known as \u201cDatabase Control System\u201d, is generally a program that provides an interface between the data/information stored and the queries received.</li> <li>It is responsible for storing, retrieving, and updating database records.</li> <li>It helps us to maintain the integrity and consistency of the database by applying the constraints.</li> <li>It is a highly flexible and scalable product that provides us with the capability of fully managed storage.</li> </ul> <p>Functions of the Storage Manager</p> <ul> <li>Converts DML statements into low-level file system commands.</li> <li>Handles large storage requirements (hundreds of gigabytes to terabytes).</li> <li>Moves data between disk storage and main memory as needed.</li> </ul> <p>Components of the Storage Manager</p> <p>1. Authorization &amp; Integrity Manager</p> <ul> <li>Enforces integrity constraints and verifies user access rights.</li> </ul> <p>2. Transaction Manager</p> <ul> <li>Ensures database consistency despite system failures.</li> <li>Handles concurrent transactions without conflicts.</li> </ul> <p>3. File Manager</p> <ul> <li>Allocates storage space and manages data structures on disk.</li> </ul> <p>4. Buffer Manager</p> <ul> <li>Fetches data from disk storage to main memory.</li> <li>Manages memory caching of frequently accessed data.</li> <li>Enabling the database to handle data sizes that are much larger than the size of the main memory.</li> </ul>"},{"location":"unit1/#disk-storage-in-dbms","title":"Disk Storage in DBMS","text":"<p>The storage manager implements several data structures as part of the physical system implementation:</p> <p>1. Data Files</p> <ul> <li>Store actual database records.</li> </ul> <p>2. Data Dictionary</p> <ul> <li>Stores metadata about the database structure, including:</li> <li>Table names, attributes, data types, and constraints.</li> <li>Indexes, views, and authorized users.</li> <li>Storage methods and optimization details.</li> </ul> <p>3. Indices</p> <ul> <li>Provide fast access to data using pointers.</li> <li>Example: Hashing can be used for quicker lookups in some cases.</li> </ul> <p>4. Statistical Data</p> <ul> <li>Stores statistical metadata, such as record count and block distribution.</li> <li>Helps optimize query execution.</li> </ul>"}]}